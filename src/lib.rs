mod command;
mod error;

pub(crate) mod exercism;
pub(crate) mod reqwest;
pub(crate) mod task;

use std::str::FromStr;

use clap::Parser;
use clap_verbosity_flag::{InfoLevel, Verbosity};
pub use error::Error;
pub use error::Result;
use tracing_subscriber::filter::Directive;
use tracing_subscriber::EnvFilter;

use crate::command::Command;

/// Main CLI application.
///
/// Derives [`Parser`] to be constructible from command-line arguments through [`clap`].
#[derive(Debug, Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    #[command(flatten)]
    verbose: Verbosity<InfoLevel>,

    #[command(subcommand)]
    command: Command,
}

impl Cli {
    /// Execute our CLI program.
    ///
    /// This method parses the arguments, sets up [`tracing`] support and executes the appropriate
    /// [`Command`]. If parsing results in an error, [`clap`] reports it automatically to the user.
    ///
    /// # Tracing support
    ///
    /// The level of verbosity for the program is controlled by the [`verbose`](Cli::verbose) flag.
    /// By default, we print [`INFO`](tracing::Level::INFO) and above, but only for our own crate
    /// (not for dependent crates like `hyper`).
    ///
    /// It is possible to change verbosity in two ways:
    ///
    /// * Use the `--verbose` or `--quiet` command-line arguments when invoking the program. These
    ///   can be specified multiple times (e.g. `-vv` will boost it to [`TRACE`](tracing::Level::TRACE)).
    /// * Set the `RUST_LOG` environment variable. This will override any verbosity specified on the
    ///   command-line. The format is similar to that supported by the [`env_logger`](https://docs.rs/env_logger/latest/env_logger/index.html) crate.
    ///   This can also be used to enable tracing for other modules (e.g. setting the environment
    ///   variable to `trace` will print everything, from all crates involved).
    pub async fn execute() -> Result<()> {
        let cli = Self::parse();

        let default_directive =
            Directive::from_str(&format!("{}={}", module_path!(), cli.verbose.log_level_filter()))
                .expect("default directive should be valid");
        let env_filter = EnvFilter::builder()
            .with_default_directive(default_directive)
            .from_env_lossy();
        tracing_subscriber::fmt().with_env_filter(env_filter).init();

        cli.command.execute().await
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod cli {
        use clap::CommandFactory;

        use super::*;

        /// This is just a very basic test for our CLI as generated by [`clap`]. Other tests will
        /// take the form of integration tests.
        #[test]
        fn test_debug_assert() {
            Cli::command().debug_assert();
        }
    }
}
